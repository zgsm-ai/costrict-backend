package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"log"
	"net/http"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"time"

	chclient "github.com/zgsm-ai/cotun/client"
	chshare "github.com/zgsm-ai/cotun/share"
	"github.com/zgsm-ai/cotun/share/cos"
)

var commonHelp = `
    --pid Generate pid file in current working directory

    -v, Enable verbose logging

    --help, This help text

  Signals:
    The cotun process is listening for:
      a SIGUSR2 to print process stats, and
      a SIGHUP to short-circuit the client reconnect timer

  Version:
    ` + chshare.BuildVersion + ` (` + runtime.Version() + `)

  Read more:
    https://github.com/zgsm-ai/cotun

`

func generatePidFile() {
	pid := []byte(strconv.Itoa(os.Getpid()))
	if err := os.WriteFile("cotun.pid", pid, 0644); err != nil {
		log.Fatal(err)
	}
}

type headerFlags struct {
	http.Header
}

func (flag *headerFlags) String() string {
	out := ""
	for k, v := range flag.Header {
		out += fmt.Sprintf("%s: %s\n", k, v)
	}
	return out
}

func (flag *headerFlags) Set(arg string) error {
	index := strings.Index(arg, ":")
	if index < 0 {
		return fmt.Errorf(`Invalid header (%s). Should be in the format "HeaderName: HeaderContent"`, arg)
	}
	if flag.Header == nil {
		flag.Header = http.Header{}
	}
	key := arg[0:index]
	value := arg[index+1:]
	flag.Header.Set(key, strings.TrimSpace(value))
	return nil
}

var clientHelp = `
  Usage: cotun [options] --server <server> <remote> [remote] [remote] ...

  <server> is the URL to the cotun server.

  <remote>s are remote connections tunneled through the server, each of
  which come in the form:

    <local-host>:<local-port>:<remote-host>:<remote-port>/<protocol>

    ■ local-host defaults to 0.0.0.0 (all interfaces).
    ■ local-port defaults to remote-port.
    ■ remote-port is required*.
    ■ remote-host defaults to 0.0.0.0 (server localhost).
    ■ protocol defaults to tcp.

  which shares <remote-host>:<remote-port> from the server to the client
  as <local-host>:<local-port>, or:

    R:<local-interface>:<local-port>:<remote-host>:<remote-port>/<protocol>

  which does reverse port forwarding, sharing <remote-host>:<remote-port>
  from the client to the server's <local-interface>:<local-port>.

    example remotes

      3000
      example.com:3000
      3000:google.com:80
      192.168.0.5:3000:google.com:80
      socks
      5000:socks
      R:2222:localhost:22
      R:socks
      R:5000:socks
      stdio:example.com:22
      1.1.1.1:53/udp

    When the cotun server has --socks5 enabled, remotes can
    specify "socks" in place of remote-host and remote-port.
    The default local host and port for a "socks" remote is
    127.0.0.1:1080. Connections to this remote will terminate
    at the server's internal SOCKS5 proxy.

    When the cotun server has --reverse enabled, remotes can
    be prefixed with R to denote that they are reversed. That
    is, the server will listen and accept connections, and they
    will be proxied through the client which specified the remote.
    Reverse remotes specifying "R:socks" will listen on the server's
    default socks port (1080) and terminate the connection at the
    client's internal SOCKS5 proxy.

    When stdio is used as local-host, the tunnel will connect standard
    input/output of this program with the remote. This is useful when
    combined with ssh ProxyCommand. You can use
      ssh -o ProxyCommand='cotun client cotunserver stdio:%h:%p' \
          user@example.com
    to connect to an SSH server through the tunnel.

  Options:

    --fingerprint, A *strongly recommended* fingerprint string
    to perform host-key validation against the server's public key.
    Fingerprint mismatches will close the connection.
    Fingerprints are generated by hashing the ECDSA public key using
    SHA256 and encoding the result in base64.
    Fingerprints must be 44 characters containing a trailing equals (=).

    --auth, An optional username and password (client authentication)
    in the form: "<user>:<pass>". These credentials are compared to
    the credentials inside the server's --authfile. defaults to the
    AUTH environment variable.

    --keepalive, An optional keepalive interval. Since the underlying
    transport is HTTP, in many instances we'll be traversing through
    proxies, often these proxies will close idle connections. You must
    specify a time with a unit, for example '5s' or '2m'. Defaults
    to '25s' (set to 0s to disable).

    --max-retry-count, Maximum number of times to retry before exiting.
    Defaults to unlimited.

    --max-retry-interval, Maximum wait time before retrying after a
    disconnection. Defaults to 5 minutes.

    --proxy, An optional HTTP CONNECT or SOCKS5 proxy which will be
    used to reach the cotun server. Authentication can be specified
    inside the URL.
    For example, http://admin:password@my-server.com:8081
            or: socks://admin:password@my-server.com:1080

    --header, Set a custom header in the form "HeaderName: HeaderContent".
    Can be used multiple times. (e.g --header "Foo: Bar" --header "Hello: World")

    --hostname, Optionally set the 'Host' header (defaults to the host
    found in the server url).

    --sni, Override the ServerName when using TLS (defaults to the
    hostname).

    --tls-ca, An optional root certificate bundle used to verify the
    cotun server. Only valid when connecting to the server with
    "https" or "wss". By default, the operating system CAs will be used.

    --tls-skip-verify, Skip server TLS certificate verification of
    chain and host name (if TLS is used for transport connections to
    server). If set, client accepts any TLS certificate presented by
    the server and any host name in that certificate. This only affects
    transport https (wss) connection. Cotun server's public key
    may be still verified (see --fingerprint) after inner connection
    is established.

    --tls-key, a path to a PEM encoded private key used for client
    authentication (mutual-TLS).

    --tls-cert, a path to a PEM encoded certificate matching the provided
    private key. The certificate must have client authentication
    enabled (mutual-TLS).

    --client-id, Client ID, will be added to HTTP request headers as X-Client-Id.
    --app-name, Application name, will be added to HTTP request headers as X-App-Name.
    --user-id, User ID, will be added to HTTP request headers as X-User-Id.
` + commonHelp

type AuthConfig struct {
	ID          string `json:"id"`
	Name        string `json:"name"`
	AccessToken string `json:"access_token"`
	MachineID   string `json:"machine_id"`
	BaseUrl     string `json:"base_url"`
}

type OptionsConfig struct {
	Options map[string]string `json:"options,omitempty"`
	Headers map[string]string `json:"headers,omitempty"`
	Server  string            `json:"server,omitempty"`
	Remotes []string          `json:"remotes,omitempty"`
}

var CostrictDir string = GetCostrictDir()

func GetCostrictDir() string {
	homeDir, _ := os.UserHomeDir()
	return filepath.Join(homeDir, ".costrict")
}

func loadAuth() (AuthConfig, error) {
	var cfg AuthConfig
	authPath := filepath.Join(CostrictDir, "share", "auth.json")

	if _, err := os.Stat(authPath); os.IsNotExist(err) {
		return cfg, err
	}
	file, err := os.Open(authPath)
	if err != nil {
		return cfg, err
	}
	defer file.Close()
	if err := json.NewDecoder(file).Decode(&cfg); err != nil {
		return cfg, err
	}
	return cfg, nil
}

func loadOptions() (OptionsConfig, error) {
	var opts OptionsConfig

	optsPath := filepath.Join(CostrictDir, "config", "cotun-options.json")
	if _, err := os.Stat(optsPath); os.IsNotExist(err) {
		return opts, err
	}
	data, err := os.ReadFile(optsPath)
	if err != nil {
		return opts, err
	}
	if err := json.Unmarshal(data, &opts); err != nil {
		return opts, err
	}
	return opts, nil
}

func parseImplicitArgs(headers *http.Header, opts OptionsConfig) error {
	for k, v := range opts.Options {
		f := flag.Lookup(k)
		if f == nil {
			return os.ErrNotExist
		}
		// 仅在命令行选项未设置值的时候才调用 f.Value.Set
		// 通过检查标志的当前值是否等于默认值来判断是否被设置
		if current := f.Value.String(); current == f.DefValue {
			if err := f.Value.Set(v); err != nil {
				return err
			}
		}
	}
	for k, v := range opts.Headers {
		headers.Set(k, v)
	}
	return nil
}

func main() {
	config := chclient.Config{Headers: http.Header{}}
	flag.StringVar(&config.Fingerprint, "fingerprint", "", "")
	flag.StringVar(&config.Auth, "auth", "", "")
	flag.DurationVar(&config.KeepAlive, "keepalive", 25*time.Second, "")
	flag.IntVar(&config.MaxRetryCount, "max-retry-count", -1, "")
	flag.DurationVar(&config.MaxRetryInterval, "max-retry-interval", 0, "")
	flag.StringVar(&config.Proxy, "proxy", "", "")
	flag.StringVar(&config.TLS.CA, "tls-ca", "", "")
	flag.BoolVar(&config.TLS.SkipVerify, "tls-skip-verify", false, "")
	flag.StringVar(&config.TLS.Cert, "tls-cert", "", "")
	flag.StringVar(&config.TLS.Key, "tls-key", "", "")
	flag.Var(&headerFlags{config.Headers}, "header", "")
	flag.StringVar(&config.Server, "server", "", "")

	hostname := flag.String("hostname", "", "")
	sni := flag.String("sni", "", "")
	pid := flag.Bool("pid", false, "")
	verbose := flag.Bool("v", false, "")
	clientId := flag.String("client-id", "", "client machine ID")
	appName := flag.String("app-name", "", "client application name")
	userId := flag.String("user-id", "", "client user ID")
	flag.Usage = func() {
		fmt.Print(clientHelp)
		os.Exit(0)
	}
	flag.Parse()
	//pull out options, put back remaining args
	args := flag.Args()
	auths, err := loadAuth()
	if err == nil {
		config.Headers.Set("X-Client-Id", auths.MachineID)
		config.Headers.Set("X-User-Id", auths.ID)
		config.Headers.Set("Authorization", fmt.Sprintf("Bearer %s", auths.AccessToken))
		if config.Server == "" {
			config.Server = fmt.Sprintf("%s/ws", auths.BaseUrl)
		}
	}
	opts, err := loadOptions()
	if err == nil {
		if err := parseImplicitArgs(&config.Headers, opts); err != nil {
			log.Fatalf("parse implicit args failed")
		}
		if opts.Server != "" {
			config.Server = opts.Server
		}
		if len(opts.Remotes) > 0 {
			config.Remotes = opts.Remotes
		}
	}
	if len(args) > 0 {
		config.Remotes = append(config.Remotes, args...)
	}
	if config.Server == "" {
		log.Fatalf("A server is required")
	}
	if len(config.Remotes) == 0 {
		log.Fatalf("Remotes is required")
	}
	//default auth
	if config.Auth == "" {
		config.Auth = os.Getenv("AUTH")
	}
	//move hostname onto headers
	if *hostname != "" {
		config.Headers.Set("Host", *hostname)
		config.TLS.ServerName = *hostname
	}

	if *sni != "" {
		config.TLS.ServerName = *sni
	}

	// 添加新的HTTP头部信息
	if *clientId != "" {
		config.Headers.Set("X-Client-Id", *clientId)
	}
	if *appName != "" {
		config.Headers.Set("X-App-Name", *appName)
	}
	if *userId != "" {
		config.Headers.Set("X-User-Id", *userId)
	}

	//ready
	c, err := chclient.NewClient(&config)
	if err != nil {
		log.Fatal(err)
	}
	c.Debug = *verbose
	if *pid {
		generatePidFile()
	}
	go cos.GoStats()
	ctx := cos.InterruptContext()
	if err := c.Start(ctx); err != nil {
		log.Fatal(err)
	}
	if err := c.Wait(); err != nil {
		log.Fatal(err)
	}
}
