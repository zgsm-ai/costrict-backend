Name: chat-rag
Host: 0.0.0.0
Port: 8888

# Logging configuration
Log:
  LogFilePath: "logs/"

PreciseContextConfig:
  EnableEnvDetailsFilter: true
  # Control which agents in which modes cannot use ModesChange
  DisabledModesChangeAgents:
    strict:
      - "strict"
      - "requirements"
      - "architect"
      - "task"
      - "review"
      - "code"
    vibe:
      - "review"
  
  # Dynamic configuration for task description content
  TaskContentReplaceRule:
    scene1: # Group name, used to distinguish different scenarios
      # Specify which agents are effective, the structure here can reuse DisabledModesChangeAgents
      # If not configured, all will be effective, be careful!
      valid_agents:
        strict: # Mode name
          - "requirements" # agent name
          - "architect"
        vibe:
          - "review"
          - "code"

      skip_key: "%skip_key%" # If content contains this flag, skip processing directly

      match_keys:
        key1: |
          "The content you want to replace key1"
        key2: |
          "The content you want to replace key2"

  AgentsMatch:
    - agent: "strict"
      key: "a strict strategic workflow controller"
    - agent: "requirements"
      key: "an experienced requirements analyst specializing"
    - agent: "code"
      key: "a highly skilled software engineer"
    - agent: "architect"
      key: "an experienced technical leader"
    - agent: "task"
      key: "a project manager specializing in task decomposition"
    - agent: "test"
      key: "a professional testing engineer"
    - agent: "testguide"
      key: "a senior architect and testing expert"
    - agent: "review"
      key: "a code review expert skilled at analyzing issues"

# Department configuration
DepartmentApiEndpoint: "http://localhost:1234/work_id?work_id="

# Models supported by function calling
LLM:
  # Endpoint: "https://zgsm.sangfor.com/chat-rag/api/v1/chat/completions"
  Endpoint: "http://127.0.0.1:30616/v1/chat/completions"
  # Endpoint: "http://127.0.0.1:32325/model/glm-4.5-fp8/v1/chat/completions"

LLMTimeout:
  # 单次连续空闲阈值（毫秒），默认 30000ms
  IdleTimeoutMs: 30000
  # 总空闲预算（毫秒），跨重试/降级累计空闲时长上限，默认 30000ms
  TotalIdleTimeoutMs: 30000

Redis:
  Addr: "127.0.0.1:6379"

# Semantic API configuration
Tools:
  # Control which agents in which modes cannot use tools
  DisabledAgents:
    strict:
      - "strict"
      - "task"

  # 新的通用工具配置结构
  GenericTools:
    # 语义搜索工具
    - name: "codebase_search"
      description: |
        Description: Find files most relevant to the search query.
        This is a semantic search tool, so the query should ask for something semantically matching what is needed.
        If it makes sense to only search in a particular directory, please specify it in the path parameter.
        Unless there is a clear reason to use your own search query, please just reuse the user's exact query with their wording.
        Their exact wording/phrasing can often be helpful for the semantic search query. 
        Keeping the same exact question format can also be helpful.
        IMPORTANT: Queries MUST be in English. Translate non-English queries before searching.
        When you need to search for relevant codes, use this tool first.

        Parameters:
        - query: (required) The search query to find relevant code. You should reuse the user's exact query/most recent message with their wording unless there is a clear reason not to.
        - path: (optional) The path to the directory to search in relative to the current working directory. This parameter should only be a directory path, file paths are not supported. Defaults to the current working directory.
        Usage:
        <codebase_search>
        <query>Your natural language query here</query>
        <path>Path to the directory to search in (optional)</path>
        </codebase_search>

        Example: Searching for functions related to user authentication
        <codebase_search>
        <query>User login and password hashing</query>
        <path>/path/to/directory</path>
        </codebase_search>
      
      capability: |
        - You can use codebase_search to perform semantic-aware searches across your codebase, 
        returning conceptually relevant code snippets based on meaning rather than exact text matches. 
        This is particularly powerful for discovering related functionality, exploring unfamiliar code architecture, 
        or locating implementations when you only understand the purpose but not the specific syntax. 
        For optimal efficiency, always try codebase_search first as it delivers more focused results with lower token consumption. 
        Reserve other tools for cases where you need literal pattern matching or precise line-by-line analysis of file contents. 
        This balanced approach ensures you get the right search method for each scenario - semantic discovery through codebase_search when possible, 
        falling back to exhaustive text search via other tools only when necessary.

      rule: |
        - Before reading the file directly, you can try to use codebase_search

      # API端点配置
      endpoints:
        search: "http://123.58.64.57:30080/codebase-embedder/api/v1/search/semantic"
        ready: "http://123.58.64.57:30080/codebase-embedder/api/v1/embeddings/summary"
      
      # 请求方法
      method: "POST"
      
      # 参数定义
      parameters:
        - name: "query"
          type: "string"
          description: "The search query to find relevant code. You should reuse the user's exact query/most recent message with their wording unless there is a clear reason not to."
          required: true
          source: "llm"  
          
        - name: "path"
          type: "string"
          description: "The path to the directory to search in relative to the current working directory. This parameter should only be a directory path, file paths are not supported. Defaults to the current working directory."
          required: false
          source: "llm"
          
        - name: "topK"
          type: "integer"
          description: "Number of results to return"
          required: false
          default: 50
          source: "manual"
          
        - name: "score"
          type: "float"
          description: "Similarity score threshold"
          required: false
          default: 0.7
          source: "manual"
              
    # 代码定义搜索工具
    - name: "search_definitions"
      description: |
        Description: Retrieve the complete definitions and implementations of one or more symbols defined within the project (not external libraries), or of symbols referenced within the code that you need to understand in context.
        This tool allows you to quickly and accurately retrieve the original definitions and full implementations of all symbols—such as constants, structs, interfaces, functions, methods, and classes—as well as their values. It can also obtain the definitions and implementations of all external symbols within a specific code block, or of a single symbol, whether used within the same file or across other files, providing complete information to facilitate understanding of the code logic.
        Compared with using the search_files tool or reading files directly, this tool is significantly more efficient, accurate, and token-friendly, allowing you to obtain results more quickly, accurately, and with lower token cost. It provides comprehensive information to help you fully understand the code logic and referenced symbols, making it the preferred method for retrieving symbol definitions.
        Key Rule:
        - Always call this tool first if the code snippet references any symbol that is not fully defined within the snippet itself.
        - This tool ensures you analyze real implementations, not incomplete or assumed logic.
        Note: 
        1. This tool only applies to seven languages: Java, Go, Python, C, CPP, JavaScript, and TypeScript. Other languages are not applicable.
        2. This tool is more efficient and uses fewer tokens than search_files tool or directly reading files to obtain symbol definitions.

        Parameters:
        - symbolNames: (required) One or more target symbol names to search for definitions. Separate each symbol name with a comma.

        Usage:
        <search_definitions>
          <symbolNames>SymbolName1,SymbolName2</symbolNames>
        </search_definitions>


        Examples:

        1. Querying the definition of a single symbol:
        <search_definitions>
          <symbolNames>QueryCallGraphOptions</symbolNames>
        </search_definitions>

        2. Querying multiple symbols (within the 8-symbol limit)
        <search_definitions>
          <symbolNames>countFilesAndSize,RelationNode,defaultCacheCapacity</symbolNames>
        </search_definitions>

        IMPORTANT: You MUST follow this Efficient Symbol Defini Definition Strategy:
        - You MUST query all related symbols in one go whenever possible (up to 8 symbols per operation).
        - You MUST NOT split the request into multiple queries if they can be searched in a single batch operation.
        - You MUST obtain all necessary context before analyzing or modifying code
        - You MUST obtain complete definition information for each referenced symbol
        - You MUST prioritize the most critical symbols first when querying multiple symbols
        - You MUST write each symbol name in PLAIN form (e.g., types.QueryCallGraphOptions → QueryCallGraphOptions), omitting any package, namespace, or class prefixes.
        - You MUST use subsequent queries for additional symbols if more than 8 need to be analyzed

        **When to Use:**
        - You need to check a symbol's full definition before editing, reviewing, or refactoring code.
        - You need to analyze a symbol's structure, logic (across files/modules) and require its definition.
        - You're troubleshooting bugs or security issues and need to understand a symbol's implementation via its definition.
        - You plan to modify a function, method, class, or constant and need its definition to assess impact.
        - You're building code context (e.g., understanding code logic) and need definitions of referenced symbols.

        **When NOT to Use:**
        - The task is minor code editing that doesn't require a symbol's complete definition.
        - The request is exploratory or informational, with no specific symbol to look up the definition for.
        - You don't have a specific symbol name to look up its definition (the tool relies on a clear symbol name to work).
      
      capability: |
        - You can use the search_definitions tool to retrieve the complete definitions and implementations of one or more specified symbols (such as constants,functions, classes, methods, interfaces, and structs) by providing their symbol names. This is particularly useful when you need to understand the detailed structure and logic of a symbol, or to gather the definitions of referenced symbols to build a more complete context within the codebase. You may need to call this tool multiple times to examine different symbols relevant to your task.
            - For example, when asked to make edits, review code, investigate bugs, analyze code, or refactor code, you might first use search_definitions to obtain the full definitions and implementations of symbols referenced within the code, in order to supplement the context and fully understand the logic. Then, analyze the structure and behavior based on the gathered definitions. If understanding how a function or method is used throughout the codebase—including how its parameters are passed, validated, and propagated in higher-level calls—is valuable for tasks such as code review or refactoring, you can use search_references to find where it is referenced in other files or modules.
            - For example, when asked to retrieve symbol definitions, use this tool to obtain results more quickly, accurately, and with lower token cost.
            - For example, when asked to retrieve, find, show, or explain specific symbol definitions such as "show me the UserService class" or "what does the calculateTax function do", you should use search_definitions to obtain results more quickly, accurately, and with lower token cost compared to searching through files manually.
      
      rule: |
        - Don't use search_files to search for symbol definitions or call chains. It is highly inefficient, consumes excessive tokens, and returns imprecise results.
        - If the search failed, don't say "failed", describe this outcome as "did not find relevant results" instead.
        - When you need to retrieve a symbol's definition, first use the search_definitions tool. This tool allows you to efficiently obtain the full definition and implementation of functions, methods, classes, interfaces, structs, or constants across the project. search_definitions is precise and consumes fewer tokens than manually searching files, providing complete and context-rich results.
        - *IMPORTANT*: The search_definitions tool may return multiple definitions for symbols with the same name. You must use context and the provided information to determine and output the most accurate symbol definition.

      endpoints:
        search: "http://127.0.0.1:9001/codebase-indexer/api/v1/search/definition"
        ready: "http://127.0.0.1:9001/codebase-indexer/api/v1/index/summary"
      
      method: "GET"
      
      parameters:
        - name: "symbolNames"
          type: "string"
          description: "One or more target symbol names to search for definitions. Separate each symbol name with a comma."
          required: false
          source: "llm"
                  
    # 引用搜索工具
    - name: "search_references"
      description: |
        Description: Retrieves the reverse call chain (caller chain) for a specified function or method within the codebase.
        Given the name of a function or method, this tool traces all other functions or methods that directly or indirectly invoke it, providing a clear and context-rich view of its upstream dependencies.
        You can specify a lineRange to precisely locate the target function or method, improving both the accuracy and efficiency of call chain generation.
        This helps developers understand how a function or method is used, its relationships, and its dependency paths across the codebase.

        **IMPORTANT: This only applies to seven languages: Java, Go, Python, C, CPP, JavaScript, and TypeScript. Other languages are not applicable.

        Parameters:
        - filePath: (required) The path of the file where the function or method is defined (relative to workspace directory)
        - maxLayer: (required) Maximum call chain depth to search (default: 4, maximum: 10)
        - symbolName: (required) The name of the function or method 
        - lineRange: (optional) The line range of the function or method definition in format "start-end" (1-based)

        Usage:

        <search_references>
          <filePath>path/to/file</filePath>
          <maxLayer>call chain depth (1-10)</maxLayer>
          <symbolName>symbol name</symbolName>
          <lineRange>start-end</lineRange>
        </search_references>

        Examples
        1. Exploring reverse call chain of the queryCallGraphBySymbol function 
        <search_references>
          <filePath>internal\service\indexer.go</filePath>
          <maxLayer>4</maxLayer>
          <symbolName>queryCallGraphBySymbol</symbolName>
        </search_references>

        2. Exploring reverse call chain of the queryCallGraphByLineRange function with lineRange:
        <search_references>
          <filePath>internal\tokenizer\tokenizer.go</filePath>
          <maxLayer>5</maxLayer>
          <symbolName>queryCallGraphByLineRange</symbolName>
          <lineRange>20-75</lineRange>
        </search_references>

      capability: |
        - You can use search_references to retrieve comprehensive usage and call information for functions and methods across the entire codebase. This tool is particularly useful when you need to locate all usages and trace reverse call chains (caller chains) of a function or method, or when analyzing code dependencies across different modules and files. Compared to manually navigating directory structures and reading file contents, this tool provides a significantly faster and more accurate way to understand calling relationships between different functions and methods.
          - For example, when asked to review code snippets, investigate bugs, or analyze code, you MUST use search_references to obtain the reverse call chain of a function or method to understand how its parameters are passed, validated, and propagated in higher-level calls, which is critical because bugs are often caused by incorrect upstream parameter passing rather than the function itself, and without checking callers you might miss that a security vulnerability exists in how upstream code passes unvalidated input or that performance issues stem from callers invoking the function too frequently in wrong contexts.
          - For example, when asked to refactor code, you must use search_references to obtain the reverse call chain of a function or method before making any changes to identify all call sites that need modification when changing function signatures, assess backward compatibility requirements, and understand different calling patterns to ensure the refactored version handles all cases, because refactoring without checking callers first will break existing functionality across potentially dozens of call sites.

      rule: |
        - When analyzing a function or method's usage across the project, first use search_references to obtain its reverse call chain. This tool allows you to efficiently locate all places where the symbol is called or referenced, including parameter propagation and higher-level dependencies. This is especially useful for bug investigation, performance analysis, security checks, and refactoring, as issues often arise from incorrect or frequent calls upstream rather than the function itself. 
        - *IMPORTANT*: The search_references tool may return call chains that include functions with the same name. You must use context and the provided information to determine and output the most accurate call chain.

      endpoints:
        search: "http://127.0.0.1:9001/codebase-indexer/api/v1/callgraph"
        ready: "http://127.0.0.1:9001/codebase-indexer/api/v1/index/summary"
      
      method: "GET"
      
      parameters:
        - name: "filePath"
          type: "string"
          description: "The path of the file where the function or method is defined (relative to workspace directory)"
          required: true
          source: "llm"
          
        - name: "symbolName"
          type: "string"
          description: "The name of the function or method"
          required: true
          source: "llm"
          
        - name: "lineRange"
          type: "string"
          description: "The line range of the function or method definition in format \"start-end\" (1-based)"
          required: false
          source: "llm"
          
        - name: "maxLayer"
          type: "integer"
          description: "Maximum call chain depth to search (default: 4, maximum: 10)"
          required: true
          source: "llm"

# Forward configuration
# 不做对请求不做任何处理，只做记录，可用来抓包
forward:
  # Enable forwarding interface
  enabled: true
  # Default target URL for forwarding (optional)
  # If not provided, target URL must be specified in query parameter
  # defaultTarget: "http://zgsm.sangfor.com/"